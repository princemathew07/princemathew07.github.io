<!DOCTYPE html>
<html>
<head>
<title>Tutorial_NuSMV.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
  width: 800px;
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="part-1-specifying-and-verifying-transition-systems-in-nusmv">Part 1: Specifying and Verifying Transition Systems in NuSMV</h1>
<blockquote>
<p>Notes based on the course on Model Checking by Prof. B. Srivathsan (CMI).
<a href="https://www.youtube.com/watch?v=5LVxrfTAJQ0&amp;list=PLK50zIm6tHRiKFJvKu1a7q_z2tcXnBUHp&amp;index=7">Lecture Video</a></p>
</blockquote>
<h2 id="1-introduction-to-nusmv-transition-systems">1. Introduction to NuSMV Transition Systems</h2>
<blockquote>
<p>NuSMV is a symbolic model checker used to describe and verify finite state transition systems.</p>
</blockquote>
<p>A transition system in NuSMV is specified by defining:</p>
<ol>
<li>The states (variables and their domains)</li>
<li>The initial states</li>
<li>The transition relations (how the system moves from one state to another)</li>
</ol>
<h2 id="2-basic-transition-system-example">2. Basic Transition System Example</h2>
<p>Scenario: A simple system with two states <code>l1</code> and <code>l2</code>. The initial state is l1, and transitions go from <code>l1</code> to <code>l2</code> and back from <code>l2</code> to <code>l1</code>.</p>
<div style="display: flex; align-items: flex-start; gap: 40px;">

  <!-- Image -->
  <div>
    <img src="./img/1.png" alt="Example" height="250">
  </div>

  <!-- Code -->
  <div>
<pre class="hljs" style="width: 400px;"><code>MODULE main
VAR
  location : {l1, l2};

ASSIGN
  init(location) := l1;
  next(location) := case
    location = l1 : l2;
    location = l2 : l1;
  esac;
</code></pre>
  </div>

</div>

<h2 id="3-running-nusmv-commands">3. Running NuSMV Commands</h2>
<p>Assuming the above code is saved in a file named <code>intro_demo.smv</code>, follow these steps in the terminal:</p>
<pre class="hljs" style="width: 600px;"><code><div>NuSMV -int
</div></code></pre>
<p>This starts NuSMV in interactive mode.
Within NuSMV, enter:</p>
<pre class="hljs" style="width: 600px;"><code><div>read_model -i intro_demo.smv
flatten_hierarchy
encode_variables
build_model
</div></code></pre>
<ul>
<li><code>read_model</code> loads the model file.</li>
<li><code>flatten_hierarchy</code> processes module hierarchies.</li>
<li><code>encode_variables</code> encodes variables for model checking.</li>
<li><code>build_model</code> completes the model construction.</li>
</ul>
<blockquote>
<p>Alternatively, do <code>NuSMV -int intro_demo.smv</code>, then <code>go</code>.</p>
</blockquote>
<h2 id="4-exploring-the-model">4. Exploring the Model</h2>
<ul>
<li>To check the initial state:
<code>pick_state -i</code></li>
<li>Expected output:
<code>location = l1</code></li>
<li>To simulate transitions for 10 steps:
<code>simulate -i -k 10</code>
<ul>
<li>You will observe the system alternating between <code>location = l1</code> and <code>location = l2</code>.</li>
</ul>
</li>
<li>To view all reachable states:
<code>print_reachable_states -v</code>
<ul>
<li>Output confirms two reachable states: <code>location = l1</code> and <code>location = l2</code>.</li>
</ul>
</li>
</ul>
<h2 id="5-extended-example-program-graph-with-variable">5. Extended Example: Program Graph with Variable</h2>
<p>Now, consider a system with:
States <code>l1</code> and <code>l2</code>.
An integer variable <code>x</code> ranging from 0 to 100.
Transition from <code>l1</code> to <code>l2</code> allowed only if <code>x &lt; 10</code>.
When moving from <code>l2</code> to <code>l1</code>, <code>x</code> increments by 1 (bounded by 100). NuSMV supports only bounded variables.</p>

<div style="display: flex; align-items: flex-start; gap: 40px; margin-bottom: 30px;"> <!-- vertical spacing -->

  <!-- Image -->
  <div>
    <img src="./img/2.png" alt="Example" height="250">
  </div>

  <!-- Code -->
  <div style="width: 650px; overflow-x: auto;"> <!-- wide code block -->
<pre class="hljs" style="width: 600px;"><code>MODULE main
VAR
  location : {l1, l2};
  x : 0..100;

ASSIGN
  init(location) := l1;
  init(x) := 0;

  next(location) := case
    (location = l1) & (x < 10) : l2;
    (location = l2) : l1;
    TRUE : location;  # Default: don't change location
  esac;

  next(x) := case
    (location = l1) : x;
    (location = l2) & (x < 100) : x + 1;
    TRUE : x;
  esac;
</code></pre>
  </div>

</div>


<h2 id="6-running-and-simulating-the-extended-model">6. Running and Simulating the Extended Model</h2>
<p>To exit the current session use the command <code>quit</code></p>
<p>Load and build the model as before:</p>
<pre class="hljs" style="width: 600px;"><code><div>read_model -i pg_demo.smv
flatten_hierarchy
encode_variables
build_model
</div></code></pre>
<p>or</p>
<pre class="hljs" style="width: 600px;"><code><div>NuSMV -int pg_demo.smv
go
</div></code></pre>
<p>Check the initial state:</p>
<ul>
<li><code>pick_state -i</code>
Expected:
<code>location = l1, x = 0</code></li>
<li>Simulate 15 steps:
<code>simulate -i -k 15</code>
<ul>
<li>Observe how <code>location</code> alternates and <code>x</code> increments when transitioning from <code>l2</code> to <code>l1</code>.</li>
</ul>
</li>
<li>Print reachable states:
<code>print_reachable_states -v</code>
<ul>
<li>You should see $21$ reachable states, due to combinations of <code>location</code> and <code>x</code> values.</li>
</ul>
</li>
</ul>
<h2 id="7-model-with-boolean-and-enum-variables">7. Model with Boolean and Enum Variables</h2>
<p>Example with: Boolean variable <code>request</code>,
Enum variable <code>status</code> is either <code>ready</code> or <code>busy</code></p>
<ul>
<li>Initial state: <code>status = ready</code>, request unspecified (hence two initial states)</li>
<li>Transitions depend on request value</li>
</ul>
<div style="display: flex; align-items: flex-start; gap: 40px;">

  <!-- Image -->
  <div>
    <img src="./img/3.png" alt="Example" height="300">
  </div>

  <!-- Code -->
  <div>
<pre class="hljs" style="width: 400px;"><code>MODULE main
VAR
  request : boolean;
  status : {ready, busy};

ASSIGN
  init(status) := ready;

  next(status) := case
    request : busy;
    TRUE : {ready, busy};
  esac;
</code></pre>
  </div>

</div>

<h2 id="8-exploring-and-simulating">8. Exploring and Simulating</h2>
<p>Loading and build:</p>
<pre class="hljs" style="width: 600px;"><code><div>NuSMV -int request_busy_demo.smv
go
</div></code></pre>
<ul>
<li>
<p>See all states (4 total):
<code>print_reachable_states -v</code></p>
</li>
<li>
<p>Simulate starting from an initial state</p>
</li>
<li>
<p><code>pick_state -i</code> to select an initial state</p>
</li>
<li>
<p><code>simulate -i -k 3</code>
You can observe transitions between various request and status values. You also have to choose the next transitions to take.</p>
</li>
</ul>
<h2 id="9-specifying-and-checking-requirements">9. Specifying and Checking Requirements</h2>
<div style="display: flex; align-items: flex-start; justify-content: center; gap: 30px;">

  <div>
    <p><strong>Example Execution 1:</strong></p>
    <img src="./img/4.png" alt="Example 1" height="500">
  </div>

  <!-- Vertical Line -->
  <div style="width: 2px; background-color: black; height: 520px;"></div>

  <div>
    <p><strong>Example Execution 2:</strong></p>
    <img src="./img/5.png" alt="Example 2" height="500">
  </div>

</div>
<blockquote>
<p>A transition system satisfies a requirement if all its executions satisfy the requirement.</p>
</blockquote>
<p>NuSMV supports temporal logic specifications, especially LTL (Linear Temporal Logic), to verify properties such as:</p>
<ul>
<li>G (Globally): Property holds in all states of all executions. eg., <code>G(x&gt;=0)</code> is <code>true</code> in EE 1. <code>G(request=0)</code> is <code>false</code> in EE 2 but is <code>true</code> for the third execution in EE 2.</li>
<li>F (Eventually): Property holds at some point in all executions. <code>F(request=1)</code> is <code>false</code> in EE 2 but <code>true</code> for the first and second executions in EE 2.</li>
</ul>
<blockquote>
<p><strong>Example 1:</strong> Check if <code>x &gt;= 0</code> always holds in <em>pg_demo.smv</em></p>
</blockquote>
<pre class="hljs" style="width: 600px;"><code><div>NuSMV -int pg_demo.smv
go
check_ltlspec -p &quot;G (x &gt;= 0)&quot;
</div></code></pre>
<p>NuSMV output will confirm whether the specification is true.</p>
<blockquote>
<p><strong>Example 2:</strong> Check if <code>request = FALSE</code> always holds in <em>request_busy_demo.smv</em></p>
</blockquote>
<pre class="hljs" style="width: 600px;"><code><div>NuSMV -int request_busy_demo.smv
go
check_ltlspec -p &quot;G (request = FALSE)&quot;
</div></code></pre>
<blockquote>
<p><code>F(request=1)</code> is <code>false</code> in EE 2 because of the third execution.</p>
</blockquote>
<p>NuSMV will state that the specification is false and provide a counterexample execution.</p>
<blockquote>
<p><strong>Example 3:</strong> Check if eventually <code>x &gt;= 5</code> holds in <em>pg_demo.smv</em> (see Example Execution 1).</p>
</blockquote>
<pre class="hljs" style="width: 600px;"><code><div>NuSMV -int pg_demo.smv
go
check_ltlspec -p &quot;F (x &gt;= 5)&quot;
</div></code></pre>
<p>Expected output: <code>Specification F x &gt;= 5 is true</code></p>
<h3 id="combining-g-and-f">Combining G and F</h3>
<blockquote>
<p><strong>Example 4:</strong> Check if whenever <code>request</code> is <code>true</code>, <code>status</code> eventually becomes <code>busy</code> in <em>request_busy_demo.smv</em></p>
</blockquote>
<pre class="hljs" style="width: 600px;"><code><div>NuSMV -int request_busy_demo.smv
go
check_ltlspec -p &quot;G (request = TRUE -&gt; F (status = busy))&quot;
</div></code></pre>
<p>NuSMV should confirm this property is <code>true</code>. This is not easy to check by just looking at the transition system.</p>
<h2 id="10-summary">10. Summary</h2>
<ul>
<li>Writing transition systems using <code>VAR</code> and <code>ASSIGN</code> blocks in NuSMV.</li>
<li>Specifying initial states using <code>init</code>.</li>
<li>Defining transitions using <code>next</code> with case statements.</li>
<li>Running NuSMV commands.</li>
<li>Checking temporal logic requirements (G and F properties) using <code>check_ltlspec</code>.</li>
</ul>
<p>This lecture prepares you to model  systems and formally verify their properties using NuSMV.</p>
<h1 id="part-2-modeling-hardware-circuits-in-nusmv">Part 2: Modeling Hardware Circuits in NuSMV</h1>
<h2 id="introduction">Introduction</h2>
<p>In this lecture, we explore how to describe hardware circuits using the NuSMV tool. Building on prior knowledge of modeling simple transition systems, we delve into three parts:</p>
<ol>
<li>Modeling a simple circuit.</li>
<li>Exploring more complex circuits like NAND gates.</li>
<li>Using hierarchical designs and modules, culminating in a 3-bit counter example.</li>
</ol>
<h2 id="1-simple-circuit-modeling">1. Simple Circuit Modeling</h2>
<h3 id="circuit-description">Circuit Description</h3>
<ul>
<li>Inputs: <code>x</code> and <code>r</code> (both boolean).</li>
<li>Output: <code>y</code> = NOT of XOR of <code>x</code> and <code>r</code>.</li>
<li>Next state of <code>r</code>: XOR of current <code>x</code> and <code>r</code>.</li>
<li><code>x</code> is nondeterministic (can be either 0 or 1).</li>
<li>Initial value of <code>r</code> is <code>false</code>; <code>x</code> can start as <code>true</code> or <code>false</code>.</li>
</ul>
<div style="display: flex; align-items: flex-start; gap: 40px;">

  <!-- Image -->
  <div>
    <img src="./img/6.png" alt="Example" height="450">
  </div>

  <!-- Code -->
  <div>
<pre class="hljs" style="width: 400px;"><code>MODULE main
VAR
  x : boolean;
  r : boolean;

DEFINE
  y := !(x xor r);

ASSIGN
  init(r) := FALSE;
  next(r) := x xor r;
</code></pre>
  </div>

</div>


<h3 id="key-modeling-details-in-nusmv">Key Modeling Details in NuSMV</h3>
<ul>
<li>Variables <code>x</code> and <code>r</code> declared in <code>VAR</code> block.</li>
<li><code>r</code>'s next value is assigned with a delay using <code>next(r) := x xor r</code>.</li>
<li>Output <code>y</code> depends immediately on current values; modeled using <code>DEFINE y := !(x xor r)</code>.</li>
<li><code>y</code> is not declared in <code>VAR</code> because it does not affect state space.</li>
<li>Number of states: 4 (2 choices for <code>x * 2</code> for <code>r</code>).</li>
</ul>

<h4 id="simulation-and-reachable-states">Simulation and Reachable States</h4>
<ul>
<li>
<p>The command <code>NuSMV -int circuit_demo1.smv</code> launches interactive mode.</p>
</li>
<li>
<p>Use the command <code>go</code> instead of <code>read_model flatten_heirarchy, encode_variables and build_model</code> -- same functionality.</p>
</li>
<li>
<p>Using <code>print_reachable_states -v</code> shows the 4 possible states.</p>
</li>
<li>
<p>Using <code>print_fair_transitions -v</code> shows all the 8 possible transitions.</p>
</li>
<li>
<p>Simulation illustrates how <code>r</code> evolves over steps, while <code>y</code> updates immediately.</p>
</li>
<li>
<p>Each state has two possible successors due to nondeterministic <code>x</code>.</p>
</li>
<li>
<p><code>pick_state -i</code> to pick an initial state.</p>
</li>
<li>
<p><code>simulate -i -k 5</code> simulates the model for five steps.</p>
</li>
</ul>
<h4 id="important-notes">Important Notes</h4>
<p>Use of <code>DEFINE</code> is crucial for outputs depending on current state without delay.
State space is determined solely by variables in <code>VAR</code>.</p>
<h2 id="2-nand-gate-examples">2. NAND Gate Examples</h2>
<p><img src="./img/7.png" alt="alt text" height="100"></p>

<div style="display: flex; align-items: flex-start; gap: 40px;">

  <!-- Image -->
  <div>
    <img src="./img/8.png" alt="Example" height="250">
  </div>

  <!-- Code -->
  <div>
<pre class="hljs" style="width: 400px;"><code>MODULE main
VAR
  in1 : boolean;
  in2 : boolean;

DEFINE
  out := !(in1 & in2);
</code></pre>
  </div>

</div>


<p>NAND Gate With Zero Delay
Inputs: <code>in1, in2</code> (boolean).
Output: <code>out = ! (in1 &amp; in2)</code>, defined with zero delay.
No initial states defined; all 4 input combinations are initial.
Transitions are unconstrained; any state can transition to any other.</p>

<ul>
<li><code>NuSMV -int nand_demo1.smv</code> followed by <code>go</code> to load the model.</li>
<li><code>print_reachable_states -v</code> to see the set of reachable states.</li>
<li><code>pick_state -i</code> Since we have not defined any initial state, any state can be initial.</li>
<li><code>simulate -i 5</code> Simulates the model for five steps. Here, all transitions are possible.
</li>
</ul>

<h4 id="nand-gate-with-unit-delay">NAND Gate With Unit Delay</h4>
<ul>
<li><code>out</code> declared as a boolean variable with initial value <code>true</code>.</li>
<li>Next value of <code>out</code> assigned as <code>NAND</code> of current inputs: <code>next(out) := !(in1 &amp; in2);</code>.</li>
<li>Inputs <code>in1</code> and <code>in2</code> remain nondeterministic.</li>
<li>Number of states: 8 (2 × 2 × 2 variables).</li>
</ul>
<div style="display: flex; align-items: flex-start; gap: 40px;">

  <!-- Image -->
  <div>
    <img src="./img/9.png" alt="Example" height="400">
  </div>

  <!-- Code -->
  <div style="width: 600px; overflow-x: auto;"> <!-- increased width -->
<pre class="hljs" style="width: 500px;"><code>MODULE main
VAR
  in1 : boolean;
  in2 : boolean;
  out : boolean;

ASSIGN
  init(out) := TRUE;
  next(out) := !(in1 & in2);
</code></pre>
  </div>

</div>

<ul>
<li><code>NuSMV -int nand_demo2.smv</code> followed by <code>go</code> to load the model.</li>
<li><code>print_reachable_states -v</code> to see all the reachable states.</li>
<li><code>pick_state -i</code> to pick an initial state.</li>
<li><code>simulate -i -k 5</code> to simulate for 5 steps.</li>
</ul>

<h4 id="behavior-and-transitions">Behavior and Transitions</h4>
<ul>
<li>Initial states: 4 states with <code>out = TRUE</code> combined with all input values.</li>
<li>Transitions depend on current inputs; output reflects delayed NAND operation.</li>
<li>Demonstrates modeling of hardware delay in NuSMV.</li>
</ul>
<h2 id="3-modular-and-hierarchical-designs">3. Modular and Hierarchical Designs</h2>
<ul>
<li>Defining a <code>NAND</code> module <code>nand2</code> with inputs <code>in1</code>, <code>in2</code> and output <code>out</code>.</li>
<li>The value of <code>out</code> is updated with unit delay.</li>
<li>Enables reuse and hierarchical design.</li>
</ul>
<pre class="hljs" style="width: 400px;"><code><div>MODULE nand2(in1, in2)
VAR
  out : boolean;

ASSIGN
  init(out) := TRUE;
  next(out) := !(in1 &amp; in2);

MODULE main
VAR
  input1 : boolean;
  input2 : boolean;
  q : nand2(input1, input2);
</div></code></pre>
<ul>
<li>
<p><code>NuSMV -int nand_demo3.smv</code>, <code>go</code></p>
</li>
<li>
<p><code>print_reachable_states -v</code> :</p>
</li>
<li>
<p>State space consists of <code>input1, input2</code>, and <code>q.out</code>.</p>
</li>
<li>
<p>Number of states: 8.</p>
</li>
<li>
<p><code>pick_state -i</code> to pick initial state.</p>
</li>
<li>
<p><code>simulate -i -k 3</code> to simulate a run for 3 steps.</p>
</li>
</ul>
<h3 id="using-multiple-nand-modules">Using Multiple NAND Modules</h3>
<blockquote>
<p>Modules becomes more useful while reusing components.</p>
</blockquote>
<p>Instantiate two <code>NAND</code> modules <code>q1</code> and <code>q2</code> with inputs <code>(x1, x2)</code> and <code>(y1, y2)</code>.
Output computed as <code>XOR</code> of <code>q1.out</code> and <code>q2.out</code>.</p>

<div style="display: flex; align-items: flex-start; gap: 40px;">

  <!-- Image -->
  <div>
    <img src="./img/10.png" alt="Example" height="200">
  </div>

  <!-- Code -->
  <div style="width: 650px; overflow-x: auto;"> <!-- increased width -->
<pre class="hljs" style="width: 600px;"><code>MODULE main
VAR
  x1 : boolean; x2 : boolean;
  y1 : boolean; y2 : boolean;
  q1 : nand2(x1, x2);
  q2 : nand2(y1, y2);

DEFINE
  fout := q1.out xor q2.out;

MODULE nand2(in1, in2)
VAR
  out : boolean;

ASSIGN
  init(out) := TRUE;
  next(out) := !(in1 & in2);
</code></pre>
  </div>

</div>

<ul>
<li>Variables: <code>x1, x2, y1, y2, q1.out, q2.out</code>.</li>
<li>Number of states: 64 (2⁶).</li>
</ul>
<h3 id="hierarchical-nand-circuit-with-feedback">Hierarchical NAND Circuit with Feedback</h3>
<p>Two <code>NAND</code> gates connected in a feedback loop. Inputs <code>x</code> and <code>y</code> are boolean. Two variables <code>q1</code> and <code>q2</code> of <code>nand2</code> type are instantiated with interdependent inputs.</p>

<div style="display: flex; align-items: flex-start; gap: 40px;">

  <!-- Image -->
  <div>
    <img src="./img/11.png" alt="Example" height="200">
  </div>

  <!-- Code -->
  <div style="width: 650px; overflow-x: auto;"> <!-- increased width -->
<pre class="hljs" style="width: 600px;"><code>MODULE main
VAR
  x : boolean;
  y : boolean;
  q1 : nand2(x, q2.out);
  q2 : nand2(q1.out, y);

DEFINE
  fout := q1.out xor q2.out;

MODULE nand2(in1, in2)
VAR
  out : boolean;

ASSIGN
  init(out) := TRUE;
  next(out) := !(in1 & in2);
</code></pre>
  </div>

</div>


<ul>
<li>
<p>Inputs: <code>x, y</code>.</p>
</li>
<li>
<p>Variables: <code>q1</code> takes (x, q2.out), <code>q2</code> takes (q1.out, y).
Feedback loop between two NAND gates.</p>
</li>
<li>
<p><code>NuSMV -int nand_demo4.smv</code>, <code>go</code> to load the model.</p>
</li>
<li>
<p><code>print_reachable_states -v</code></p>
</li>
<li>
<p>Number of states: <code>16</code> (2⁴).</p>
</li>
<li>
<p>Initial states: Both <code>q1.out</code> and <code>q2.out</code> start as <code>TRUE</code>.</p>
</li>
<li>
<p><code>pick_state -i</code> to pick an initial state.</p>
</li>
<li>
<p>Next states computed synchronously using <code>NAND</code> of inputs.</p>
</li>
</ul>
<ul>
<li>Number of states = 16 (2 × 2 × 2 × 2 for <code>x, y, q1.out, q2.out</code>).</li>
<li>Initial values for <code>q1.out</code> and <code>q2.out</code> are <code>TRUE</code> as per module definition.</li>
<li>Next states computed by <code>NAND</code> on current inputs.</li>
<li>Feedback between <code>q1</code> and <code>q2</code> creates complex state transitions.</li>
<li>Simulations show how output variables update synchronously.</li>
</ul>
<pre class="hljs" style="width: 600px;"><code><div>NuSMV -int nand-demo5.smv
go
print_reachable_states -v
pick_state -i
simulate -i k 5
</div></code></pre>
<h2 id="4-example-3-bit-counter-using-modules">4. Example: 3-Bit Counter Using Modules</h2>
<ul>
<li>Module: counter_cell</li>
<li>Input: carryin (boolean).</li>
<li>Variables: <code>value</code> (bit), <code>carryout</code> (boolean).
<ul>
<li><code>carryout</code> defined as <code>carryin &amp; value</code>.</li>
<li>Next state of value is <code>value XOR carryin</code>.
</ul>
</li>
</ul>

<p><code>bit0</code> <code>carryin</code> is always <code>TRUE</code>.
<code>bit1</code> and <code>bit2</code> carryin depend on previous bit's carryout.
This constructs a synchronous 3-bit binary counter.</p>
<ul>
<li>Operation and State Transitions
Initial state: all bits <code>FALSE</code>.
Each step updates all bits simultaneously.
The counter counts from 000 to 111 and wraps around.
Demonstrates synchronous composition: all modules update in lockstep.</li>
</ul>
<h2 id="5-summary">5. Summary</h2>
<ul>
<li>NuSMV models hardware circuits as transition systems with boolean variables.</li>
<li>Variables in <code>VAR</code> define the state space; outputs dependent on current state can be modeled with <code>DEFINE</code>.</li>
<li>Using <code>next(variable)</code> captures unit delay behavior.</li>
<li>Modules enable hierarchical and reusable designs.
Feedback loops and synchronous composition are naturally expressed with modules.</li>
<li>The 3-bit counter example illustrates practical synchronous module composition.</li>
<li>Future topics include asynchronous composition, where modules update independently.</li>
<li>This lecture provided a detailed journey from simple circuits to hierarchical modular designs in NuSMV, emphasizing state space modeling, delays, and the power of modularity in hardware description.</li>
</ul>
<h1 id="part-3-modeling-parallel-systems-using-nusmv">Part 3: Modeling Parallel Systems using NuSMV</h1>
<p>We cover modeling synchronous and asynchronous parallel systems, mutual exclusion, and concurrent programs using NuSMV. We explore examples with traffic lights, mutual exclusion for shared resources, and concurrent programs manipulating a shared variable.</p>
<h2 id="1-introduction-to-parallel-systems">1. Introduction to Parallel Systems</h2>
<ul>
<li><strong>Parallel systems</strong> are also called <strong>concurrent systems</strong>.</li>
<li>Two main kinds:
<ul>
<li><strong>Synchronous systems</strong>: All components move simultaneously at each transition step.</li>
<li><strong>Asynchronous systems</strong>: Components move independently; one component transitions at a time.</li>
</ul>
</li>
</ul>
<h2 id="2-traffic-light-example-synchronous-vs-asynchronous-systems">2. Traffic Light Example: Synchronous vs Asynchronous Systems</h2>
<p><img src="./img/13.png" alt="alt text" height="350"></p>
<h3 id="system-description">System Description</h3>
<ul>
<li>Two traffic lights: <code>l1</code> and <code>l2</code>.</li>
<li>Each has three states: <code>red (r)</code>, <code>yellow (y)</code>, <code>green (g)</code>.</li>
<li>Interaction constraints:
<ul>
<li>A light can only go from <code>red</code> to <code>yellow</code> if the other light is <code>red</code>.</li>
<li>A light can remain in <code>red</code> or <code>green</code> for arbitrary periods.</li>
<li>A light must go from <code>yellow</code> to <code>green</code> immediately in the next transition.</li>
</ul>
</li>
<li>Goal: Prevent both lights turning green simultaneously.</li>
</ul>
<div style="display: flex; align-items: flex-start; gap: 40px; margin-bottom: 30px;"> <!-- adds vertical space -->

  <!-- Image -->
  <div>
    <img src="./img/14.png" alt="Example" height="240">
  </div>

  <!-- Code -->
  <div style="width: 650px; overflow-x: auto;"> <!-- wider code block -->
<pre class="hljs" style="width: 600px;"><code>MODULE light(other)
VAR
  state : {r, y, g};

ASSIGN
  init(state) := r;
  next(state) := case
    state = r & other = r : {r, y};
    state = y : g;
    state = g : {g, r};
    TRUE : state;
  esac;

MODULE main
VAR
  tl1 : light(tl2.state);
  tl2 : light(tl1.state);
</code></pre>
  </div>

</div>

<ul>
<li>Both lights update states simultaneously.</li>
<li>Problem: Both lights can become green at the same time, which is undesirable.</li>
</ul>
<h3 id="asynchronous-composition">Asynchronous Composition</h3>

<ul>
<li>Use <code>process</code> keyword to declare asynchronous modules.</li>
<li>Only one process executes at a time, chosen nondeterministically.</li>
</ul>
<div style="display: flex; align-items: flex-start; gap: 40px; margin-bottom: 30px;"> <!-- vertical spacing -->

  <!-- Image -->
  <div>
    <img src="./img/15.png" alt="Example" height="220">
  </div>

  <!-- Code -->
  <div style="width: 450px; overflow-x: auto;"> <!-- wide code block -->
<pre class="hljs" style="width: 400px;"><code>MODULE main
VAR
  tl1 : process light(tl2.state);
  tl2 : process light(tl1.state);
</code></pre>
  </div>

</div>



<pre class="hljs" style="width: 600px;"><code><div>NuSMV -int light_asyn_demo.smv
go
check_ltlspec -p &quot;!( F (tl1.state=g &amp; tl2.state = g))

</div></code></pre>
<ul>
<li>Ensures only one light changes state per step.</li>
<li>Prevents both lights from turning green simultaneously.</li>
<li>This models asynchronous behavior where no global clock synchronizes transitions.</li>
</ul>
<h3 id="verification">Verification</h3>
<p>-Property checked:  Never both green simultaneously.</p>
<ul>
<li>NuSMV confirms the property holds in asynchronous composition.</li>
</ul>
<pre class="hljs" style="width: 600px;"><code><div>print_reachable_states -v
pick_state -i
simulate -i -k 3
</div></code></pre>
<h2 id="3-mutual-exclusion-example">3. Mutual Exclusion Example</h2>
<div style="display: flex; align-items: flex-start; gap: 40px; margin-bottom: 30px;"> <!-- vertical space with margin-bottom -->

  <!-- Image -->
  <div>
    <img src="./img/16.png" alt="Example" height="500">
  </div>

  <!-- Code -->
  <div style="width: 650px; overflow-x: auto;"> <!-- increased width -->
<pre class="hljs" style="width: 600px;"><code>MODULE thread(y)
VAR
  location : {nc, w, c, e};

ASSIGN
  init(location) := nc;
  next(location) := case
    location = nc : {nc, w};
    location = w & y > 0 : c;
    location = c : {c, e};
    location = e : nc;
    TRUE : location;
  esac;

  next(y) := case
    location = w & y > 0 : y - 1;
    location = e & y = 0 : y + 1;
    TRUE : y;
  esac;

MODULE main
VAR
  ymain : 0..1;
  p1 : process thread(ymain);
  p2 : process thread(ymain);

ASSIGN
  init(ymain) := 1;
</code></pre>
  </div>

</div>



<p>Two parallel programs sharing a resource.</p>
<ul>
<li>Each program has 4 states:
<ol>
<li>noncritical (nc)</li>
<li>waiting (w)</li>
<li>critical (c)</li>
<li>exiting (e)</li>
</ol>
</li>
<li>A global variable <code>y</code> (0 or 1) controls access.</li>
<li>Programs enter critical section only if <code>y &gt; 0</code>, decrementing <code>y</code>.</li>
<li>On exit, <code>y</code> is incremented.</li>
<li>Mutual exclusion means both cannot be in critical section simultaneously.</li>
</ul>

<pre class="hljs" style="width: 600px;"><code><div>NuSMV -int mutex_demo1.smv
go
check_ltlspec -p &quot;!F(p1.location=c &amp; p2.location=c)&quot;
</div></code></pre>
<h3 id="verification">Verification</h3>
<ul>
<li>Property checked: Never both in critical section simultaneously.</li>
<li>NuSMV confirms the property holds.</li>
</ul>
<pre class="hljs" style="width: 600px;"><code><div>pick_state -i
simulate -i -k 3
</div></code></pre>
<h2 id="4-concurrent-programs-with-shared-variable">4. Concurrent Programs with Shared Variable</h2>
<p><img src="./img/17.png" alt="alt text" height="400"></p>
<ul>
<li>Three parallel programs manipulating integer <code>x</code>  (bounded between -1000 and 1000).</li>
</ul>
<pre class="hljs" style="width: 600px;"><code><div>MODULE program1(x)
VAR
  location : {l1, l2};
ASSIGN
  init(location) := l1;
  next(location) := case
                    location = l1 &amp; x &lt; 200 : l2;
                    location = l2 : l1;
                    TRUE : location;
                  esac;

  next(x) := case
              location = l2 &amp; x &lt; 1000 : x + 1;
              TRUE : x;
            esac;

MODULE program2(x)
VAR
  location : {m1, m2};
ASSIGN
  init(location) := m1;
  next(location) := case
                  location = m1 &amp; x &gt; 0 : m2;
                  location = m2 : m1;
                  TRUE : location;
                esac;

  next(x) := case
              location = m2 &amp; x &gt; -1000 : x - 1;
              TRUE : x;
            esac;

MODULE program3(x)
VAR
  location : {n1, n2};
ASSIGN
  init(location) := n1;
  next(location) := case
                    location = n1 &amp; x = 200 : n2;
                    location = n2 : n1;
                    TRUE : location;
                  esac;

  next(x) := case
              location = n2 : 0;
              TRUE : x;
            esac;

MODULE main
VAR
  x : -1000..1000;
  thread1 : process program1(x);
  thread2 : process program2(x);
  thread3 : process program3(x);
ASSIGN
  init(x) := 0;
</div></code></pre>
<pre class="hljs" style="width: 600px;"><code><div>NuSMV -int three_program_demo.smv
go 
check_ltlspec -p &quot;G (x&gt;=0)&quot; 
</div></code></pre>
<h3 id="verification">Verification</h3>
<ul>
<li>Property: <code>x</code> always non-negative.</li>
<li>NuSMV returns <code>false</code> with a counterexample where <code>x</code> becomes negative due to interleaving of increments and decrements.</li>
<li>Simulation shows behavior leading to <code>x = -1</code>.</li>
</ul>
<h2 id="5-summary">5. Summary</h2>
<ul>
<li>Synchronous systems: All components transition simultaneously.</li>
<li>Asynchronous systems: Only one component transitions at a time, modeled using the <code>process</code> keyword.</li>
<li>Mutual exclusion: Modeled with shared variables and state machines ensuring critical sections do not overlap.</li>
<li>Concurrent programs: Interaction of multiple programs on shared variables can be modeled and verified using NuSMV.</li>
<li>NuSMV can check temporal properties and find counterexamples to incorrect models.</li>
<li>Modeling requires care; simulation help identify errors.</li>
</ul>

</body>
</html>
